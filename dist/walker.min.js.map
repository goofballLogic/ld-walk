{"version":3,"file":"walker.min.js","sources":["../node_modules/url-template/lib/url-template.js","../src/walker.js"],"sourcesContent":["(function (root, factory) {\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else {\n        root.urltemplate = factory();\n    }\n}(this, function () {\n  /**\n   * @constructor\n   */\n  function UrlTemplate() {\n  }\n\n  /**\n   * @private\n   * @param {string} str\n   * @return {string}\n   */\n  UrlTemplate.prototype.encodeReserved = function (str) {\n    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\n      if (!/%[0-9A-Fa-f]/.test(part)) {\n        part = encodeURI(part).replace(/%5B/g, '[').replace(/%5D/g, ']');\n      }\n      return part;\n    }).join('');\n  };\n\n  /**\n   * @private\n   * @param {string} str\n   * @return {string}\n   */\n  UrlTemplate.prototype.encodeUnreserved = function (str) {\n    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n      return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n  }\n\n  /**\n   * @private\n   * @param {string} operator\n   * @param {string} value\n   * @param {string} key\n   * @return {string}\n   */\n  UrlTemplate.prototype.encodeValue = function (operator, value, key) {\n    value = (operator === '+' || operator === '#') ? this.encodeReserved(value) : this.encodeUnreserved(value);\n\n    if (key) {\n      return this.encodeUnreserved(key) + '=' + value;\n    } else {\n      return value;\n    }\n  };\n\n  /**\n   * @private\n   * @param {*} value\n   * @return {boolean}\n   */\n  UrlTemplate.prototype.isDefined = function (value) {\n    return value !== undefined && value !== null;\n  };\n\n  /**\n   * @private\n   * @param {string}\n   * @return {boolean}\n   */\n  UrlTemplate.prototype.isKeyOperator = function (operator) {\n    return operator === ';' || operator === '&' || operator === '?';\n  };\n\n  /**\n   * @private\n   * @param {Object} context\n   * @param {string} operator\n   * @param {string} key\n   * @param {string} modifier\n   */\n  UrlTemplate.prototype.getValues = function (context, operator, key, modifier) {\n    var value = context[key],\n        result = [];\n\n    if (this.isDefined(value) && value !== '') {\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        value = value.toString();\n\n        if (modifier && modifier !== '*') {\n          value = value.substring(0, parseInt(modifier, 10));\n        }\n\n        result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));\n      } else {\n        if (modifier === '*') {\n          if (Array.isArray(value)) {\n            value.filter(this.isDefined).forEach(function (value) {\n              result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));\n            }, this);\n          } else {\n            Object.keys(value).forEach(function (k) {\n              if (this.isDefined(value[k])) {\n                result.push(this.encodeValue(operator, value[k], k));\n              }\n            }, this);\n          }\n        } else {\n          var tmp = [];\n\n          if (Array.isArray(value)) {\n            value.filter(this.isDefined).forEach(function (value) {\n              tmp.push(this.encodeValue(operator, value));\n            }, this);\n          } else {\n            Object.keys(value).forEach(function (k) {\n              if (this.isDefined(value[k])) {\n                tmp.push(this.encodeUnreserved(k));\n                tmp.push(this.encodeValue(operator, value[k].toString()));\n              }\n            }, this);\n          }\n\n          if (this.isKeyOperator(operator)) {\n            result.push(this.encodeUnreserved(key) + '=' + tmp.join(','));\n          } else if (tmp.length !== 0) {\n            result.push(tmp.join(','));\n          }\n        }\n      }\n    } else {\n      if (operator === ';') {\n        if (this.isDefined(value)) {\n          result.push(this.encodeUnreserved(key));\n        }\n      } else if (value === '' && (operator === '&' || operator === '?')) {\n        result.push(this.encodeUnreserved(key) + '=');\n      } else if (value === '') {\n        result.push('');\n      }\n    }\n    return result;\n  };\n\n  /**\n   * @param {string} template\n   * @return {function(Object):string}\n   */\n  UrlTemplate.prototype.parse = function (template) {\n    var that = this;\n    var operators = ['+', '#', '.', '/', ';', '?', '&'];\n\n    return {\n      expand: function (context) {\n        return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\n          if (expression) {\n            var operator = null,\n                values = [];\n\n            if (operators.indexOf(expression.charAt(0)) !== -1) {\n              operator = expression.charAt(0);\n              expression = expression.substr(1);\n            }\n\n            expression.split(/,/g).forEach(function (variable) {\n              var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n              values.push.apply(values, that.getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n            });\n\n            if (operator && operator !== '+') {\n              var separator = ',';\n\n              if (operator === '?') {\n                separator = '&';\n              } else if (operator !== '#') {\n                separator = operator;\n              }\n              return (values.length !== 0 ? operator : '') + values.join(separator);\n            } else {\n              return values.join(',');\n            }\n          } else {\n            return that.encodeReserved(literal);\n          }\n        });\n      }\n    };\n  };\n\n  return new UrlTemplate();\n}));\n","import urlTemplate from \"url-template\";\r\n\r\nconst walker = {\r\n\r\n    walk(pathContext, dependencies = {}) {\r\n\r\n        const jsonld = dependencies.jsonld;\r\n        const ld = dependencies[\"ld-query\"];\r\n\r\n        return {\r\n            pathContext: pathContext,\r\n            from: walkFrom.bind(this, pathContext)\r\n        };\r\n\r\n\r\n        function initializeQueryForWalking(expanded) {\r\n            /*\r\n                We always walk using an empty @context becuase we expand all the terms needed prior to walking\r\n            */\r\n            return ld(expanded, {});\r\n        }\r\n\r\n        /*\r\n            Given a URL, we want to download the document referenced, expand it and convert it to an ld-query object.\r\n            Note that we pass in an empty context object. This is because we will make all our queries using fully-qualified terms\r\n        */\r\n        async function URLtoQuery(url) {\r\n            try {\r\n\r\n                const expandedDoc = await jsonld.expand(url);\r\n                return initializeQueryForWalking(expandedDoc);\r\n\r\n            } catch (err) {\r\n\r\n                if (err.details && err.details.code == \"loading document failed\")\r\n                    return null;\r\n\r\n                throw err;\r\n\r\n            }\r\n        }\r\n\r\n        /*\r\n            This will execute a walk, starting from a walkFrom URL (if specified). If not specified,\r\n            lastFetched and query must be specified so that the walk can be resumed from that point.\r\n\r\n            walkTo is the definition of the path to walk (a string, or an array of strings)\r\n\r\n            lastFetched and query, if specified, are the last URL which we dereferenced when the previous\r\n            walk completed, and the query we ended on, respectively\r\n        */\r\n        async function executeWalk({ pathContext, walkFrom, walkTo, lastFetched, query, suppressFinalDereferencing }) {\r\n\r\n            // if necessary convert walkTo to an array\r\n            if(!Array.isArray(walkTo)) walkTo = (walkTo || \"\").split(\" \");\r\n\r\n            // expand the steps we are going to walk\r\n            const steps = await expandWalkToSteps(pathContext, walkTo);\r\n\r\n            // fetch the starting point document if needed\r\n            if (!lastFetched) {\r\n\r\n                query = await URLtoQuery(walkFrom);\r\n                lastFetched = walkFrom;\r\n\r\n            }\r\n\r\n            // step through until we can't any more\r\n            let stepCount = 0;\r\n            let err;\r\n            let bookmarkedQuery;\r\n            while (query && query.query && steps.length) {\r\n\r\n                // next term, and note the step, bookmark the last query\r\n                const step = steps.shift();\r\n                stepCount++;\r\n                bookmarkedQuery = query;\r\n\r\n                /*\r\n                    Steps will contain one of the following:\r\n                        - term (a normal walk term)\r\n                        - query (a query to run to change the context)\r\n                */\r\n                let nextQuery\r\n                if(\"term\" in step) {\r\n                    // a normal walk term\r\n\r\n                    // this is the query that ld-query needs to query into the document\r\n                    const term = step[\"term\"];\r\n                    const termPath = `> ${term}`;\r\n                    nextQuery = query.query(termPath);\r\n\r\n                    // not found - could be remote?\r\n                    if (!nextQuery) {\r\n                        const maybeId = query.query(\"> @id\");\r\n                        if (maybeId) {\r\n\r\n                            // try dereferencing this\r\n                            lastFetched = maybeId;\r\n                            const fetched = await URLtoQuery(maybeId);\r\n                            nextQuery = fetched && fetched.query(termPath);\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                } else if(\"id\" in step) {\r\n\r\n                    const soughtId = step[\"id\"];\r\n                    /* try to find the id locally, then remote if necessary */\r\n                    nextQuery = await walkToIdentifiedObject(soughtId);\r\n\r\n                } else if(\"query\" in step) {\r\n\r\n                    /*\r\n                        we will carry out this query using the pathContext supplied, so create a new query object with that context\r\n                    */\r\n                    const temporaryQuery = ld(query.json(), pathContext);\r\n                    /*\r\n                        1. conduct our query to find the json within this document\r\n                        2. traverse to the parent\r\n                    */\r\n                    const queryResult = temporaryQuery.query(step.query);\r\n                    const queryParent = queryResult && queryResult.parent();\r\n\r\n                    // reinitialize the query for walking\r\n                    nextQuery = queryParent && initializeQueryForWalking(queryParent.json());\r\n\r\n                } else if(\"template\" in step) {\r\n\r\n                    const template = step[\"template\"];\r\n                    const [ templatePath, templateArguments ] = template.split(\",\").map(x => x && x.trim());\r\n                    try {\r\n                        // find and expand the template\r\n                        const expandedTemplate = await expandTemplate(templatePath, templateArguments, { pathContext, query });\r\n                        // if we got one, walk to the identified object\r\n                        nextQuery = expandedTemplate && await walkToIdentifiedObject(expandedTemplate);\r\n\r\n                    } catch(caught) {\r\n                        err = caught;\r\n                        nextQuery = undefined;\r\n                    }\r\n\r\n\r\n                } else {\r\n\r\n                    throw new Error(\"Unhandled step: \" + JSON.stringify(step));\r\n\r\n                }\r\n\r\n                // At this point the query is either populated, or is null (in which case the walk will terminate)\r\n                query = nextQuery;\r\n\r\n            }\r\n\r\n            /*\r\n                at the end of the walk, we check to see where we are and if we ever dereferenced the @id (if any)\r\n                This can be suppressed using the suppressFinalDereferencing switch\r\n            */\r\n            if (!suppressFinalDereferencing && query && query.query) {\r\n\r\n                const finalId = query.query(\"> @id\");\r\n                if (finalId && finalId !== lastFetched) {\r\n\r\n                    query = await URLtoQuery(finalId) || query;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            /*\r\n                This factory function exists so that a result can produce more results after operations such\r\n                as template expansion\r\n            */\r\n            const succeeded = !!query;\r\n            const result = {\r\n                /*\r\n                    These terms are the ones we managed to walk through. Note that even if all the steps\r\n                    were walked, the query still may not have succeeded if the final step took us to a\r\n                    null document\r\n                */\r\n                walked: walkTo.slice(0, stepCount),\r\n                /*\r\n                    Takes the output of the current walk and converts it to an ldquery object\r\n                */\r\n                toQuery: (maybeContext) => query && ld(query.json(), maybeContext || {}),\r\n                /*\r\n                    This allows the consumer to continue walking from the point where they left off.\r\n                    If the previous walk failed, this will return the same result object\r\n                    that this was called on (to allow chaining)\r\n                */\r\n                continueTo: (nextWalkTo, nextOptions) => succeeded\r\n                    ? executeWalk({ ...nextOptions, pathContext, walkTo: nextWalkTo, lastFetched, query })\r\n                    : result,\r\n                /*\r\n                    If we didn't end up with a populated ld-query, it means the walk failed to find anything,\r\n                    either because it was aborted part of the way through, or because the final step resulted\r\n                    in a null document\r\n                */\r\n                succeeded,\r\n                /*\r\n                    Template expansion needs to take the current query (if any), transform it, and then walk\r\n                    to the result\r\n                */\r\n                viaTemplate: (prop, args) => succeeded\r\n                    ? expandTemplateAndWalk(prop, args, { pathContext, lastFetched, query })\r\n                    : result,\r\n\r\n            };\r\n\r\n            if (err) {\r\n                /*\r\n                    If an error object is supplied, it is expected to contain a message property and the json\r\n                    of the query to provide some context\r\n                */\r\n               result.err = { message: err.message, json: bookmarkedQuery ? bookmarkedQuery.json() : null };\r\n\r\n            }\r\n            if (!result.succeeded) {\r\n                /*\r\n                    we didn't find what we were looking for - report any steps we didn't get to.\r\n                    We anticipate that if someone fails the walk, they will want to know if it failed\r\n                    part of the way through which bits remained unwalked.\r\n                */\r\n                result.notWalked = walkTo.slice(stepCount);\r\n            }\r\n            return result;\r\n\r\n\r\n            async function walkToIdentifiedObject(soughtId) {\r\n                // try to find this id locally first\r\n                let nextQuery = query.query(`[@id=${soughtId}]`);\r\n                // not found - could be remote?\r\n                if (!nextQuery) {\r\n                    // try dereferencing this\r\n                    lastFetched = soughtId;\r\n                    nextQuery = await URLtoQuery(soughtId);\r\n                }\r\n                return nextQuery;\r\n            }\r\n        }\r\n\r\n        /*\r\n            Coming into this function, we have a path to the template property and some args to expand\r\n            the template once located.\r\n\r\n            If at any point in the function we fail, we will return a result object with succeeded: false\r\n            and the reason indicated as result.err\r\n        */\r\n        async function expandTemplateAndWalk(templatePath, templateArgs, walkArgs) {\r\n\r\n            try {\r\n                // expand the template so we know where to talk to next\r\n                const expandedTemplate = await expandTemplate(templatePath, templateArgs, walkArgs);\r\n\r\n                // now we have the expanded template (Hopefully a URI), walk to it\r\n                return executeWalk({ ...walkArgs, walkTo: [`id[${expandedTemplate}]`] });\r\n\r\n            } catch(err) {\r\n\r\n                // on an error, indicate failure with error message and context\r\n                const query = walkArgs && walkArgs.query;\r\n                return { succeeded: false, err: { message: err.message, json: query ? query.json() : null }};\r\n\r\n            }\r\n        }\r\n\r\n        /*\r\n            This function will expand a template and return it, but there is no protection against thrown errors.\r\n            As such, this is a shared implementation which needs to be handled by the caller carefully.\r\n        */\r\n        async function expandTemplate(templatePath, templateArgs, { pathContext, query }) {\r\n            if (!query)\r\n                throw new Error(\"No query object during template expansion\");\r\n            if (!templatePath)\r\n                throw new Error(\"No template path specified\");\r\n            // it's possible to pass in a string of JSON rather than an object for the args\r\n            if (typeof templateArgs === \"string\")\r\n                templateArgs = JSON.parse(templateArgs);\r\n            // first thing we need to do is to expand the template path\r\n            const expandedTemplatePath = await expandWalkToSteps(pathContext, [templatePath]);\r\n            if (!(expandedTemplatePath[0] && expandedTemplatePath[0].term))\r\n                throw new Error(\"Aborting - template path expansion failed (e.g. resulted in an empty string)\");\r\n            const templateTerm = expandedTemplatePath[0].term;\r\n            // now lets see if we have an actual template\r\n            let template = query.query(`> ${templateTerm}`);\r\n            if (!template)\r\n                throw new Error(`Failed to locate template ${templateTerm}`);\r\n            // we might have a final node, or we might need to get the @value\r\n            if (template.query)\r\n                template = template.query(\"@value\");\r\n            // now we should have the actual template to expand\r\n            if (!template)\r\n                throw new Error(\"Template property has no value to expand\");\r\n            const expandedTemplate = urlTemplate.parse(template).expand(templateArgs);\r\n            return expandedTemplate;\r\n        }\r\n\r\n        function parseFunctionalTerm(term) {\r\n            /*\r\n                we need to parse a term which (might) define a function which will take the form of e.g.\r\n                    my-magic-function[arugments here]\r\n                where function name id \"my-magic-function\" and arugments are \"arguments here\"\r\n            */\r\n            if (!term) return;\r\n            const matched = /^([^\\[]+)\\[(.*)\\]$/.exec(term);\r\n            if (!matched) return;\r\n            return { [`http://__ldwalk/${matched[1]}`]: matched[2] };\r\n        }\r\n\r\n        async function expandWalkToSteps(pathContext, walkTo) {\r\n            const expansionDocument = {\r\n                \"@context\": [\r\n                    pathContext,\r\n                    {\r\n                        \"http://__ldwalk/term\": { \"@type\": \"@vocab\" }\r\n                    }\r\n                ],\r\n                \"@graph\": walkTo.map(function (t) {\r\n\r\n                    const parsedFunctionalTerm = parseFunctionalTerm(t);\r\n                    if(parsedFunctionalTerm) {\r\n                        /*\r\n                            this will look like { \"http://__ldwalk/query\": \"[@type=Collection]\" }\r\n                            where the value is the ld-query to execute as part of the walk\r\n\r\n                            or\r\n\r\n                            { \"http://__ldwalk/id\": \"http://somewhere.com/something\" }\r\n                            where the value is the id we want to locate within the document (or potentially dereference)\r\n                        */\r\n                        return parsedFunctionalTerm;\r\n                    }\r\n                    /*\r\n                        this will look like { \"http://__ldwalk/term\": \"products\" }\r\n                        It is assumed that this will be the normal way to walk\r\n                    */\r\n                    return { \"http://__ldwalk/term\": t };\r\n                })\r\n            };\r\n            // this will make everything fully qualified\r\n            const expandedDocument = await jsonld.expand(expansionDocument);\r\n            const isGraph = expandedDocument.length > 1;\r\n            // this compacts it again, leaving terms other than __ldwalk ones fully qualified\r\n            const compactedDocument = await jsonld.compact(expandedDocument, { \"@context\": { \"@vocab\": \"http://__ldwalk/\", \"term\": { \"@id\": \"http://__ldwalk/term\", \"@type\": \"@id\" } } });\r\n            /*\r\n                the resulting document will end up with either have a @graph in it:\r\n                    in which case we are going to return the raw @graph, which will look something like:\r\n                        [ { term: 'things' }, { query: '*[name=\"Some oranges\"]' } ]\r\n                or it will be a simple object:\r\n                    so we need to encapsulate it in an array, like this (and we remove the @context):\r\n                        [ { term: 'things' } ]\r\n            */\r\n            if(isGraph)\r\n                return compactedDocument[\"@graph\"];\r\n            else {\r\n                delete compactedDocument[\"@context\"];\r\n                return [ compactedDocument ];\r\n            }\r\n        }\r\n\r\n        function walkFrom(pathContext, walkFrom) {\r\n            return {\r\n                pathContext: pathContext,\r\n                walkFrom: walkFrom,\r\n                to: (walkTo, options) => executeWalk({ ...options, pathContext, walkFrom, walkTo })\r\n            };\r\n        }\r\n    }\r\n};\r\n\r\nexport default walker;"],"names":["module","UrlTemplate","prototype","encodeReserved","str","split","map","part","test","encodeURI","replace","join","encodeUnreserved","encodeURIComponent","c","charCodeAt","toString","toUpperCase","encodeValue","operator","value","key","this","isDefined","isKeyOperator","getValues","context","modifier","result","substring","parseInt","push","Array","isArray","filter","forEach","Object","keys","k","tmp","length","parse","template","that","operators","expand","_","expression","literal","values","indexOf","charAt","substr","variable","exec","apply","separator","factory","walker","walk","pathContext","dependencies","jsonld","ld","from","walkFrom","to","walkTo","options","executeWalk","bind","initializeQueryForWalking","expanded","URLtoQuery","url","err","details","code","lastFetched","query","suppressFinalDereferencing","steps","expandWalkToSteps","bookmarkedQuery","stepCount","step","shift","nextQuery","termPath","maybeId","fetched","soughtId","walkToIdentifiedObject","queryResult","json","queryParent","parent","Error","JSON","stringify","templatePath","templateArguments","x","trim","expandedTemplate","expandTemplate","caught","undefined","finalId","succeeded","walked","slice","toQuery","maybeContext","continueTo","nextWalkTo","nextOptions","viaTemplate","prop","args","templateArgs","walkArgs","message","expandTemplateAndWalk","notWalked","expandedTemplatePath","term","templateTerm","urlTemplate","expansionDocument","t","parsedFunctionalTerm","matched","parseFunctionalTerm","expandedDocument","isGraph","compactedDocument","compact"],"mappings":"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"}